import { describe, it, before, after } from 'node:test';
import assert from 'node:assert/strict';
import { existsSync, mkdirSync, writeFileSync, rmSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Import the module under test
const mod = await import('../.claude/helpers/context-persistence-hook.mjs');
const {
  SQLiteBackend,
  JsonFileBackend,
  resolveBackend,
  createHashEmbedding,
  hashContent,
  parseTranscript,
  extractTextContent,
  extractToolCalls,
  extractFilePaths,
  chunkTranscript,
  extractSummary,
  buildEntry,
  storeChunks,
  retrieveContext,
  NAMESPACE,
} = mod;

// Test fixtures
const TMP_DIR = join(__dirname, '.tmp-ctx-test');
const TMP_DB = join(TMP_DIR, 'test-archive.db');
const TMP_ARCHIVE = join(TMP_DIR, 'test-archive.json');
const TMP_TRANSCRIPT = join(TMP_DIR, 'test-transcript.jsonl');

function makeUserMsg(text) {
  return { role: 'user', content: [{ type: 'text', text }] };
}

function makeAssistantMsg(text, toolCalls = []) {
  const content = [{ type: 'text', text }];
  for (const tc of toolCalls) {
    content.push({ type: 'tool_use', name: tc.name, input: tc.input });
  }
  return { role: 'assistant', content };
}

function makeToolResultMsg(toolUseId, content) {
  return { role: 'user', content: [{ type: 'tool_result', tool_use_id: toolUseId, content }] };
}

// Setup / teardown
before(() => {
  if (!existsSync(TMP_DIR)) mkdirSync(TMP_DIR, { recursive: true });
});

after(() => {
  if (existsSync(TMP_DIR)) rmSync(TMP_DIR, { recursive: true, force: true });
});

// ============================================================================
// SQLite Backend Tests
// ============================================================================

describe('SQLiteBackend', () => {
  it('should initialize and create schema', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'init-test.db'));
    await backend.initialize();
    const count = await backend.count();
    assert.equal(count, 0);
    await backend.shutdown();
  });

  it('should store and query entries', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'store-sqlite.db'));
    await backend.initialize();

    const now = Date.now();
    const entry = {
      id: 'sql-1', key: 'test:1', content: 'hello world', type: 'episodic',
      namespace: NAMESPACE, tags: ['test'], metadata: { sessionId: 'sess-1', chunkIndex: 0, contentHash: 'abc', summary: 'test' },
      accessLevel: 'private', createdAt: now, updatedAt: now, version: 1,
      accessCount: 0, lastAccessedAt: now,
    };
    await backend.store(entry);

    const results = await backend.query({ namespace: NAMESPACE });
    assert.equal(results.length, 1);
    assert.equal(results[0].content, 'hello world');
    assert.equal(results[0].metadata.sessionId, 'sess-1');

    await backend.shutdown();
  });

  it('should query by session with indexed lookup', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'session-query.db'));
    await backend.initialize();

    const now = Date.now();
    for (let i = 0; i < 5; i++) {
      await backend.store({
        id: `sq-${i}`, key: `test:${i}`, content: `turn ${i}`, type: 'episodic',
        namespace: NAMESPACE, tags: [], metadata: { sessionId: 'sess-a', chunkIndex: i, contentHash: `h${i}`, summary: `s${i}` },
        accessLevel: 'private', createdAt: now + i, updatedAt: now + i, version: 1,
        accessCount: 0, lastAccessedAt: now + i,
      });
    }
    // Different session
    await backend.store({
      id: 'sq-other', key: 'test:other', content: 'other session', type: 'episodic',
      namespace: NAMESPACE, tags: [], metadata: { sessionId: 'sess-b', chunkIndex: 0, contentHash: 'other', summary: 'other' },
      accessLevel: 'private', createdAt: now, updatedAt: now, version: 1,
      accessCount: 0, lastAccessedAt: now,
    });

    const sessA = await backend.queryBySession(NAMESPACE, 'sess-a');
    assert.equal(sessA.length, 5);
    // Should be ordered by chunk_index DESC
    assert.equal(sessA[0].metadata.chunkIndex, 4);

    const sessB = await backend.queryBySession(NAMESPACE, 'sess-b');
    assert.equal(sessB.length, 1);

    await backend.shutdown();
  });

  it('should dedup via hashExists', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'hash-dedup.db'));
    await backend.initialize();

    const now = Date.now();
    await backend.store({
      id: 'hd-1', key: 'test:1', content: 'data', type: 'episodic',
      namespace: NAMESPACE, tags: [], metadata: { contentHash: 'unique-hash-123', sessionId: 's', chunkIndex: 0, summary: '' },
      accessLevel: 'private', createdAt: now, updatedAt: now, version: 1,
      accessCount: 0, lastAccessedAt: now,
    });

    assert.ok(backend.hashExists('unique-hash-123'));
    assert.ok(!backend.hashExists('nonexistent-hash'));

    await backend.shutdown();
  });

  it('should bulk insert in a transaction', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'bulk-sqlite.db'));
    await backend.initialize();

    const now = Date.now();
    const entries = Array.from({ length: 100 }, (_, i) => ({
      id: `bulk-${i}`, key: `test:${i}`, content: `content ${i}`, type: 'episodic',
      namespace: NAMESPACE, tags: ['bulk'], metadata: { sessionId: 'bulk-sess', chunkIndex: i, contentHash: `bh${i}`, summary: `s${i}` },
      accessLevel: 'private', createdAt: now + i, updatedAt: now + i, version: 1,
      accessCount: 0, lastAccessedAt: now + i,
    }));

    await backend.bulkInsert(entries);
    const count = await backend.count(NAMESPACE);
    assert.equal(count, 100);

    await backend.shutdown();
  });

  it('should list sessions with counts', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'sessions-list.db'));
    await backend.initialize();

    const now = Date.now();
    for (let s = 0; s < 3; s++) {
      for (let i = 0; i < (s + 1) * 2; i++) {
        await backend.store({
          id: `sl-${s}-${i}`, key: `test:${s}:${i}`, content: `c`, type: 'episodic',
          namespace: NAMESPACE, tags: [], metadata: { sessionId: `sess-${s}`, chunkIndex: i, contentHash: `slh${s}${i}`, summary: '' },
          accessLevel: 'private', createdAt: now + s * 100 + i, updatedAt: now, version: 1,
          accessCount: 0, lastAccessedAt: now,
        });
      }
    }

    const sessions = await backend.listSessions(NAMESPACE);
    assert.equal(sessions.length, 3);
    // Most recent session first
    assert.equal(sessions[0].session_id, 'sess-2');
    assert.equal(sessions[0].cnt, 6);

    await backend.shutdown();
  });

  it('should persist across close/reopen', async () => {
    const dbPath = join(TMP_DIR, 'persist-sqlite.db');
    const now = Date.now();

    const b1 = new SQLiteBackend(dbPath);
    await b1.initialize();
    await b1.store({
      id: 'p-1', key: 'test:1', content: 'persisted', type: 'episodic',
      namespace: NAMESPACE, tags: [], metadata: { sessionId: 'ps', chunkIndex: 0, contentHash: 'ph1', summary: 's' },
      accessLevel: 'private', createdAt: now, updatedAt: now, version: 1,
      accessCount: 0, lastAccessedAt: now,
    });
    await b1.shutdown();

    const b2 = new SQLiteBackend(dbPath);
    await b2.initialize();
    const results = await b2.queryBySession(NAMESPACE, 'ps');
    assert.equal(results.length, 1);
    assert.equal(results[0].content, 'persisted');
    await b2.shutdown();
  });
});

// ============================================================================
// JsonFileBackend Tests
// ============================================================================

describe('JsonFileBackend', () => {
  it('should initialize empty', async () => {
    const backend = new JsonFileBackend(join(TMP_DIR, 'empty.json'));
    await backend.initialize();
    const count = await backend.count();
    assert.equal(count, 0);
    await backend.shutdown();
  });

  it('should store and query entries', async () => {
    const path = join(TMP_DIR, 'json-store.json');
    const backend = new JsonFileBackend(path);
    await backend.initialize();

    await backend.store({ id: '1', namespace: 'ns1', content: 'hello', metadata: {} });
    await backend.store({ id: '2', namespace: 'ns2', content: 'world', metadata: {} });

    const ns1 = await backend.query({ namespace: 'ns1' });
    assert.equal(ns1.length, 1);
    assert.equal(ns1[0].content, 'hello');

    await backend.shutdown();
  });

  it('should queryBySession', async () => {
    const path = join(TMP_DIR, 'json-session.json');
    const backend = new JsonFileBackend(path);
    await backend.initialize();

    await backend.store({ id: 'js1', namespace: NAMESPACE, content: 'a', metadata: { sessionId: 's1', chunkIndex: 0 } });
    await backend.store({ id: 'js2', namespace: NAMESPACE, content: 'b', metadata: { sessionId: 's1', chunkIndex: 1 } });
    await backend.store({ id: 'js3', namespace: NAMESPACE, content: 'c', metadata: { sessionId: 's2', chunkIndex: 0 } });

    const results = await backend.queryBySession(NAMESPACE, 's1');
    assert.equal(results.length, 2);
    // Descending chunk order
    assert.equal(results[0].metadata.chunkIndex, 1);

    await backend.shutdown();
  });

  it('should hashExists', async () => {
    const path = join(TMP_DIR, 'json-hash.json');
    const backend = new JsonFileBackend(path);
    await backend.initialize();

    await backend.store({ id: 'jh1', namespace: NAMESPACE, content: 'x', metadata: { contentHash: 'hash-abc' } });

    assert.ok(backend.hashExists('hash-abc'));
    assert.ok(!backend.hashExists('hash-xyz'));

    await backend.shutdown();
  });
});

// ============================================================================
// resolveBackend Tests
// ============================================================================

describe('resolveBackend', () => {
  it('should resolve to sqlite when better-sqlite3 is available', async () => {
    const { backend, type } = await resolveBackend();
    assert.equal(type, 'sqlite');
    await backend.shutdown();
  });
});

// ============================================================================
// createHashEmbedding Tests
// ============================================================================

describe('createHashEmbedding', () => {
  it('should produce 768-dimensional embedding', () => {
    const emb = createHashEmbedding('hello world');
    assert.equal(emb.length, 768);
    assert.ok(emb instanceof Float32Array);
  });

  it('should be L2-normalized', () => {
    const emb = createHashEmbedding('test embedding normalization');
    let norm = 0;
    for (let i = 0; i < emb.length; i++) norm += emb[i] * emb[i];
    norm = Math.sqrt(norm);
    assert.ok(Math.abs(norm - 1.0) < 0.001, `Norm should be ~1.0, got ${norm}`);
  });

  it('should be deterministic', () => {
    const a = createHashEmbedding('deterministic test');
    const b = createHashEmbedding('deterministic test');
    for (let i = 0; i < a.length; i++) assert.equal(a[i], b[i]);
  });

  it('should produce different embeddings for different text', () => {
    const a = createHashEmbedding('hello');
    const b = createHashEmbedding('goodbye');
    let same = true;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { same = false; break; }
    }
    assert.ok(!same);
  });
});

// ============================================================================
// hashContent Tests
// ============================================================================

describe('hashContent', () => {
  it('should produce SHA-256 hex string', () => {
    const h = hashContent('hello');
    assert.equal(h.length, 64);
    assert.match(h, /^[a-f0-9]{64}$/);
  });

  it('should be deterministic', () => {
    assert.equal(hashContent('same'), hashContent('same'));
  });

  it('should differ for different content', () => {
    assert.notEqual(hashContent('a'), hashContent('b'));
  });
});

// ============================================================================
// Transcript Parsing Tests
// ============================================================================

describe('parseTranscript', () => {
  it('should parse JSONL file', () => {
    const lines = [
      JSON.stringify({ role: 'user', content: [{ type: 'text', text: 'hello' }] }),
      JSON.stringify({ role: 'assistant', content: [{ type: 'text', text: 'hi' }] }),
    ];
    writeFileSync(TMP_TRANSCRIPT, lines.join('\n'), 'utf-8');
    const msgs = parseTranscript(TMP_TRANSCRIPT);
    assert.equal(msgs.length, 2);
    assert.equal(msgs[0].role, 'user');
  });

  it('should return empty for missing file', () => {
    assert.equal(parseTranscript('/nonexistent/file.jsonl').length, 0);
  });

  it('should skip malformed lines', () => {
    writeFileSync(TMP_TRANSCRIPT, '{"role":"user"}\nnot json\n{"role":"assistant"}\n', 'utf-8');
    assert.equal(parseTranscript(TMP_TRANSCRIPT).length, 2);
  });
});

// ============================================================================
// Content Extraction Tests
// ============================================================================

describe('extractTextContent', () => {
  it('should extract from content array', () => {
    const msg = { content: [{ type: 'text', text: 'hello' }, { type: 'text', text: 'world' }] };
    assert.equal(extractTextContent(msg), 'hello\nworld');
  });

  it('should extract from string content', () => {
    assert.equal(extractTextContent({ content: 'simple string' }), 'simple string');
  });

  it('should handle null/undefined', () => {
    assert.equal(extractTextContent(null), '');
    assert.equal(extractTextContent(undefined), '');
  });

  it('should skip non-text blocks', () => {
    const msg = { content: [
      { type: 'text', text: 'keep' },
      { type: 'tool_use', name: 'Read' },
      { type: 'text', text: 'this' },
    ]};
    assert.equal(extractTextContent(msg), 'keep\nthis');
  });
});

describe('extractToolCalls', () => {
  it('should extract tool_use blocks', () => {
    const msg = { content: [
      { type: 'text', text: 'hello' },
      { type: 'tool_use', name: 'Edit', input: { file_path: '/src/a.ts' } },
      { type: 'tool_use', name: 'Bash', input: { command: 'npm test' } },
    ]};
    const calls = extractToolCalls(msg);
    assert.equal(calls.length, 2);
    assert.equal(calls[0].name, 'Edit');
  });

  it('should handle null message', () => {
    assert.deepEqual(extractToolCalls(null), []);
  });
});

describe('extractFilePaths', () => {
  it('should extract and deduplicate paths', () => {
    const calls = [
      { name: 'Edit', input: { file_path: '/src/a.ts' } },
      { name: 'Read', input: { file_path: '/src/a.ts' } },
      { name: 'Glob', input: { path: '/src' } },
    ];
    const paths = extractFilePaths(calls);
    assert.equal(paths.length, 2);
    assert.ok(paths.includes('/src/a.ts'));
    assert.ok(paths.includes('/src'));
  });
});

// ============================================================================
// Chunking Tests
// ============================================================================

describe('chunkTranscript', () => {
  it('should group user+assistant pairs', () => {
    const messages = [
      makeUserMsg('first'), makeAssistantMsg('first answer'),
      makeUserMsg('second'), makeAssistantMsg('second answer'),
    ];
    const chunks = chunkTranscript(messages);
    assert.equal(chunks.length, 2);
  });

  it('should skip synthetic tool result messages', () => {
    const messages = [
      makeUserMsg('do something'),
      makeAssistantMsg('running tool', [{ name: 'Bash', input: { command: 'ls' } }]),
      makeToolResultMsg('id1', 'file1.txt'),
      makeAssistantMsg('done'),
    ];
    assert.equal(chunkTranscript(messages).length, 1);
  });

  it('should filter non user/assistant messages', () => {
    const messages = [
      { role: 'system', content: 'init' },
      makeUserMsg('hello'),
      makeAssistantMsg('hi'),
    ];
    assert.equal(chunkTranscript(messages).length, 1);
  });

  it('should handle empty messages', () => {
    assert.deepEqual(chunkTranscript([]), []);
  });
});

// ============================================================================
// Summary Extraction Tests
// ============================================================================

describe('extractSummary', () => {
  it('should produce summary within 300 chars', () => {
    const chunk = {
      userMessage: makeUserMsg('Implement user authentication with OAuth2'),
      assistantMessage: makeAssistantMsg('I\'ll implement OAuth2 authentication.'),
      toolCalls: [
        { name: 'Edit', input: { file_path: '/src/auth.ts' } },
      ],
      turnIndex: 0,
    };
    const summary = extractSummary(chunk);
    assert.ok(summary.length <= 300);
    assert.ok(summary.includes('OAuth2') || summary.includes('authentication'));
  });

  it('should handle empty chunk', () => {
    const summary = extractSummary({
      userMessage: null, assistantMessage: null, toolCalls: [], turnIndex: 0,
    });
    assert.ok(summary.length <= 300);
  });
});

// ============================================================================
// Entry Building Tests
// ============================================================================

describe('buildEntry', () => {
  it('should produce valid memory entry', () => {
    const chunk = {
      userMessage: makeUserMsg('test question'),
      assistantMessage: makeAssistantMsg('test answer'),
      toolCalls: [{ name: 'Read', input: { file_path: '/src/x.ts' } }],
      turnIndex: 5,
    };
    const entry = buildEntry(chunk, 'session-123', 'auto', '2026-02-10T00:00:00Z');

    assert.ok(entry.id.startsWith('ctx-'));
    assert.ok(entry.key.startsWith('transcript:session-123:5:'));
    assert.equal(entry.type, 'episodic');
    assert.equal(entry.namespace, NAMESPACE);
    assert.ok(entry.tags.includes('transcript'));
    assert.ok(entry.tags.includes('session-123'));
    assert.ok(entry.tags.includes('Read'));
    assert.equal(entry.metadata.sessionId, 'session-123');
    assert.equal(entry.metadata.chunkIndex, 5);
    assert.ok(entry.metadata.contentHash);
    assert.deepEqual(entry.metadata.filePaths, ['/src/x.ts']);
  });
});

// ============================================================================
// Store + Dedup Tests (with SQLite)
// ============================================================================

describe('storeChunks (SQLite)', () => {
  it('should store chunks and dedup duplicates', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'dedup-sqlite.db'));
    await backend.initialize();

    const chunks = [{
      userMessage: makeUserMsg('hello'),
      assistantMessage: makeAssistantMsg('hi'),
      toolCalls: [],
      turnIndex: 0,
    }];

    const r1 = await storeChunks(backend, chunks, 'sess1', 'auto');
    assert.equal(r1.stored, 1);
    assert.equal(r1.deduped, 0);

    const r2 = await storeChunks(backend, chunks, 'sess1', 'auto');
    assert.equal(r2.stored, 0);
    assert.equal(r2.deduped, 1);

    await backend.shutdown();
  });
});

describe('storeChunks (JSON fallback)', () => {
  it('should store chunks and dedup duplicates', async () => {
    const backend = new JsonFileBackend(join(TMP_DIR, 'dedup-json.json'));
    await backend.initialize();

    const chunks = [{
      userMessage: makeUserMsg('hello'),
      assistantMessage: makeAssistantMsg('hi'),
      toolCalls: [],
      turnIndex: 0,
    }];

    const r1 = await storeChunks(backend, chunks, 'sess1', 'auto');
    assert.equal(r1.stored, 1);

    const r2 = await storeChunks(backend, chunks, 'sess1', 'auto');
    assert.equal(r2.stored, 0);
    assert.equal(r2.deduped, 1);

    await backend.shutdown();
  });
});

// ============================================================================
// Context Retrieval Tests
// ============================================================================

describe('retrieveContext', () => {
  it('should build restoration text (SQLite)', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'retrieve-sqlite.db'));
    await backend.initialize();

    const now = Date.now();
    const entries = Array.from({ length: 5 }, (_, i) => ({
      id: `r${i}`, key: `test:${i}`, content: `Turn ${i} content`, type: 'episodic',
      namespace: NAMESPACE, tags: [],
      metadata: { sessionId: 'sess-abc', chunkIndex: i, summary: `Summary of turn ${i}`, toolNames: ['Read', 'Edit'], filePaths: ['/src/file.ts'], contentHash: `rh${i}` },
      accessLevel: 'private', createdAt: now + i, updatedAt: now + i, version: 1,
      accessCount: 0, lastAccessedAt: now + i,
    }));
    await backend.bulkInsert(entries);

    const ctx = await retrieveContext(backend, 'sess-abc', 4000);
    assert.ok(ctx.includes('Restored Context'));
    assert.ok(ctx.includes('5 archived turns'));
    assert.ok(ctx.includes('Summary of turn'));
    assert.ok(ctx.length <= 4200); // budget + header + footer

    await backend.shutdown();
  });

  it('should return empty for unknown session', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'empty-retrieve.db'));
    await backend.initialize();
    assert.equal(await retrieveContext(backend, 'unknown', 4000), '');
    await backend.shutdown();
  });

  it('should respect budget constraint', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'budget-sqlite.db'));
    await backend.initialize();

    const now = Date.now();
    const entries = Array.from({ length: 50 }, (_, i) => ({
      id: `bg${i}`, key: `test:${i}`, content: 'x'.repeat(200), type: 'episodic',
      namespace: NAMESPACE, tags: [],
      metadata: { sessionId: 'budget-sess', chunkIndex: i, summary: `Long summary text for turn ${i} with padding`, toolNames: ['Edit', 'Write', 'Bash'], filePaths: ['/src/very/long/path.tsx'], contentHash: `bgh${i}` },
      accessLevel: 'private', createdAt: now + i, updatedAt: now + i, version: 1,
      accessCount: 0, lastAccessedAt: now + i,
    }));
    await backend.bulkInsert(entries);

    const ctx = await retrieveContext(backend, 'budget-sess', 500);
    assert.ok(ctx.length <= 700); // budget + header + footer

    await backend.shutdown();
  });
});

// ============================================================================
// No-op Condition Tests
// ============================================================================

describe('no-op conditions', () => {
  it('should not restore for non-matching session', async () => {
    const backend = new SQLiteBackend(join(TMP_DIR, 'noop-sqlite.db'));
    await backend.initialize();

    const now = Date.now();
    await backend.store({
      id: 'noop1', key: 'test:1', content: 'data', type: 'episodic',
      namespace: NAMESPACE, tags: [],
      metadata: { sessionId: 'other-session', chunkIndex: 0, contentHash: 'nph1', summary: 's' },
      accessLevel: 'private', createdAt: now, updatedAt: now, version: 1,
      accessCount: 0, lastAccessedAt: now,
    });

    assert.equal(await retrieveContext(backend, 'my-session', 4000), '');
    await backend.shutdown();
  });
});
